package urbachyannick.approxflow.codetransformation;

import org.objectweb.asm.*;
import org.objectweb.asm.tree.*;
import urbachyannick.approxflow.javasignatures.*;

import java.util.*;
import java.util.stream.*;

import static urbachyannick.approxflow.codetransformation.BytecodeUtil.*;

// For parameters "@PublicOutput(maxInstances = <maxInstances>) <type> <param>" of method <method>
// where <maxInstances> > 0 and <type> is primitive,
// - creates the following:
//     - "public static <type>[] <method>_<param>_array = new <type>[<maxInstances>];"
//     - "public static int <method>_<param>_counter = 0;"
//     - "public static void <method>_<param>_overflow(@PublicOutput(maxInstances = 0) <type> <param>) { }"
// - generates additional code at the start of the method that does the following:
//     if (<method>_<param>_counter < <maxInstances>) {
//         <method>_<param>_array[counter++] = <param>;
//     } else {
//         <method>_<param>_overflow(<param>);
//     }
//
// parameters with <maxInstances> <= 0 (including those of the overflow methods generated by this class) are handled by
// ParameterOutputOverApproximated.
public class ParameterOutput extends Transformation.PerClassNoExcept {

    @Override
    public ClassNode applyToClass(ClassNode sourceClass) {
        ClassNode targetClass = new ClassNode(Opcodes.ASM5);
        sourceClass.accept(targetClass);

        MethodNode classInit = targetClass.methods.stream()
                .filter(m -> m.name.equals("<clinit>"))
                .findFirst()
                .orElseGet(() -> {
                    MethodNode m = new MethodNode(
                            Opcodes.ASM5,
                            Opcodes.ACC_STATIC,
                            "<clinit>",
                            "()V",
                            null,
                            null
                    );
                    m.instructions.add(new InsnNode(Opcodes.RETURN));
                    targetClass.methods.add(m);
                    return m;
                });

        List<OutputParameter> parameters = getOutputParameters(targetClass).collect(Collectors.toList());

        for (OutputParameter parameter : parameters)
            applyForParameter(targetClass, classInit, parameter);

        return targetClass;
    }

    private static void applyForParameter(ClassNode class_, MethodNode classInit, OutputParameter parameter) {
        String methodQualifiedName = parameter.method.name + "$$" + parameter.parameterIndex;
        String arrayName = "$$" + methodQualifiedName + "$$array";
        String counterName = "$$" + methodQualifiedName + "$$counter";
        String arrayType = "[" + parameter.parameterType.asTypeSpecifierString();
        String overflowMethodName = "$$" + methodQualifiedName + "$$overflow";

        FieldNode outputArray = new FieldNode(
                Opcodes.ASM5,
                Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC,
                arrayName,
                arrayType,
                null,
                null
        );
        outputArray.visibleAnnotations = new ArrayList<>();
        outputArray.visibleAnnotations.add(new AnnotationNode(Opcodes.ASM5, "Lurbachyannick/approxflow/PublicOutput;"));
        class_.fields.add(outputArray);

        FieldNode counter = new FieldNode(
                Opcodes.ASM5,
                Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC,
                counterName,
                "I",
                null,
                null
        );
        counter.visibleAnnotations = new ArrayList<>();
        // already included in io order, so obsolete now
        // counter.visibleAnnotations.add(new AnnotationNode(Opcodes.ASM5, "Lurbachyannick/approxflow/PublicOutput;"));
        class_.fields.add(counter);

        MethodNode overflowMethod = new MethodNode(
                Opcodes.ASM5,
                Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC,
                overflowMethodName,
                "(" + parameter.parameterType.asTypeSpecifierString() + ")V",
                null,
                null
        ) {{
            visibleParameterAnnotations = new List[]{
                    new ArrayList<AnnotationNode>() {{
                        add(new AnnotationNode(Opcodes.ASM5, "Lurbachyannick/approxflow/PublicOutput;") {{
                            values = new ArrayList<Object>() {{
                                add("maxInstances");
                                add(0);
                            }};
                        }});
                    }}
            };

            instructions.add(new LabelNode());
            instructions.add(new InsnNode(Opcodes.RETURN));
            instructions.add(new LabelNode());

            maxLocals = 1;
        }};

        class_.methods.add(overflowMethod);

        LabelNode startLabel = new LabelNode();
        LabelNode skipLabel = new LabelNode();

        InsnList newInstructions = new InsnList() {{
            // if (counter < maxInstances) {
            //     array[counter] = param;
            //     param = default;
            // }
            //
            // overflow(param);
            // counter++;

            add(startLabel);

            // if (counter < maxInstances)
            add(new FieldInsnNode(Opcodes.GETSTATIC, class_.name, counterName, "I"));
            add(new LdcInsnNode(parameter.maxInstances));
            add(new JumpInsnNode(Opcodes.IF_ICMPGE, skipLabel));

            // {
            //     array[counter++] = param;
            add(new FieldInsnNode(Opcodes.GETSTATIC, class_.name, arrayName, arrayType));
            add(new FieldInsnNode(Opcodes.GETSTATIC, class_.name, counterName, "I"));
            add(new VarInsnNode(parameter.parameterType.getLoadLocalOpcode(), parameter.parameterIndex));
            add(new InsnNode(parameter.parameterType.getArrayStoreOpcode()));
            //     param = default;
            add(new InsnNode(parameter.parameterType.getLoadDefaultOpcode()));
            add(new VarInsnNode(parameter.parameterType.getStoreLocalOpcode(), parameter.parameterIndex));

            // }
            add(skipLabel);

            // overflow(param);
            add(new VarInsnNode(parameter.parameterType.getLoadLocalOpcode(), parameter.parameterIndex));
            add(new MethodInsnNode(Opcodes.INVOKESTATIC, class_.name, overflowMethod.name, overflowMethod.desc));
            // counter++;
            add(new FieldInsnNode(Opcodes.GETSTATIC, class_.name, counterName, "I"));
            add(new InsnNode(Opcodes.ICONST_1));
            add(new InsnNode(Opcodes.IADD));
            add(new FieldInsnNode(Opcodes.PUTSTATIC, class_.name, counterName, "I"));
        }};

        parameter.method.instructions.insertBefore(parameter.method.instructions.getFirst(), newInstructions);


        InsnList classInitInstructions = new InsnList() {{
            // array = new ParamType[maxInstances];
            add(new LdcInsnNode(parameter.maxInstances));
            add(new IntInsnNode(Opcodes.NEWARRAY, parameter.parameterType.getTypeOpcode()));
            add(new FieldInsnNode(Opcodes.PUTSTATIC, class_.name, arrayName, arrayType));
        }};


        classInit.instructions.insertBefore(classInit.instructions.getFirst(), classInitInstructions);
    }

    // --- following class and method shared with ParameterOutputOverApproximated; default access is intentional. ---

    static class OutputParameter {
        public MethodNode method;
        public TypeSpecifier[] parameterTypes;
        public TypeSpecifier returnType;
        public int parameterIndex;
        public int maxInstances;
        public PrimitiveType parameterType;
        public boolean isInvalid; // can't throw in stream operations...
    }

    static Stream<OutputParameter> getOutputParameters(ClassNode class_) {
        return class_.methods.stream()
                .filter(method ->
                        method.visibleParameterAnnotations != null &&
                        !method.desc.startsWith("()") // has parameters
                )
                .flatMap(method -> {
                    List<TypeSpecifier> parameterTypeSpecifiers = getArgumentTypes(method).collect(Collectors.toList());
                    TypeSpecifier returnType = getReturnType(method);

                    return IntStream.range(0, parameterTypeSpecifiers.size())
                            .filter(i -> hasAnnotation(method.visibleParameterAnnotations[i], "Lurbachyannick/approxflow/PublicOutput;"))
                            .mapToObj(i -> {
                                AnnotationNode annotationNode = getAnnotation(method.visibleParameterAnnotations[i], "Lurbachyannick/approxflow/PublicOutput;").get();

                                OutputParameter result = new OutputParameter();
                                result.method = method;
                                result.parameterTypes = parameterTypeSpecifiers.toArray(new TypeSpecifier[0]);
                                result.returnType = returnType;
                                result.parameterIndex = i;
                                result.maxInstances = (int) (Integer) getAnnotationValue(annotationNode, "maxInstances").orElse(16);

                                TypeSpecifier parameterType = parameterTypeSpecifiers.get(i);

                                if (!parameterType.isPrimitive()) {
                                    result.isInvalid = true;
                                    return result;
                                }

                                result.parameterType = parameterType.asPrimitive();

                                return result;
                            });
                })
                .filter(parameter -> !parameter.isInvalid);
    }
}
